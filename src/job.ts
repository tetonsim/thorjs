export {};

/**
 * Prescribes the displacement upon a given portion of the model geometry. Typically, this is used to fix a part of the
 * model (fix the displacement at zero).
 * This object is polymorphic. The attributes depend on the value of the "type" attribute.
 * The type attribute represents the type of boundary condition. The only, current, boundary condition type is "fixed".
 */
export interface BoundaryCondition {
  /**
   * type = "fixed"
   */
  type: string;
  /**
   * A unique name for the boundary condition.
   */
  name: string;
  /**
   * The name of the chop.mesh.Mesh this boundary condition is applied to.
   */
  mesh: string;
  /**
   * A list of face ids on "mesh" that this boundary condition is applied to.
   */
  face: Array<number>;
}

/**
 * The process of "chopping" a model is to take the print configuration, including the model geometry and create
 * a finite element model. Therefore, this object defines the geometry, slicer settings, and boundary conditions
 * (such as fixed surfaces, applied loads, etc.).
 */
export interface Model {
  /**
   * A list of all of the surface mesh geometries. One printable mesh is required (and currently only one is
   * supported). Additional modifier meshes can also be specified in this list.
   */
  meshes: Array<Mesh> | Array<null>;
  /**
   * A list of the loading steps. Currently, only one step is supported.
   */
  steps: Step;
  /**
   * The slicing engine to use and all associated properties.
   */
  slicer: Slicer;
}

/**
 * Establishes a relationship between an extruder on the printer and the bulk materials that can be used with the extruder.
 */
export interface Extruders {
  /**
   * The extruder number (counting starts at zero)
   */
  id: number;
  /**
   * The names of the bulk materials that are usable in this extruder
   */
  diameter: number;
  /**
   * Current column number [if this function was defined in a script]
   */
  print_config: PrintConfig;
}

/**
 * Establishes a relationship between an extruder on the printer and the bulk materials that can be used with the extruder.
 */
export interface Extruder {
  /**
   * The extruder number (counting starts at zero)
   */
  number: number;
  /**
   * The names of the bulk materials that are usable in this extruder
   */
  usable_material: Array<string>;
}

/**
 * Fracture properties.
 */
export interface Fracture {
  /**
   * Mode I fracture toughness.
   */
  KIc: number;
}

/**
 * FDM infill configuration.
 */
export interface Infill {
  /**
   * The name of the infill pattern. Valid values are "grid", "triangle", "triangles", and "cubic".
   */
  pattern: string;
  /**
   * The infill density (in percentage of volume). The density must be greater than or equal to 20 and less than
   * 95. Solid parts can be generated by increasing the number of bottom_layers/top_layers counts rather than setting
   * the infill density to 100.
   */
  density: number;
  /**
   * The angle of the infill pattern in degrees. 0 degrees is aligned with the print x-axis.
   */
  orientation: number;
}

/**
 * Linear elastic material properties. All moduli should be given in units of MPa.
 * This object is polymorphic. The attributes depend on the value of the "type" attribute.
 */
export interface IsotropicElastic {
  /**
   * type = "isotropic"
   */
  type: string;
  /**
   * Elastic modulus
   */
  E: number;
  /**
   * Poisson ratio
   */
  nu: number;
}

/**
 * Linear elastic material properties. All moduli should be given in units of MPa.
 * This object is polymorphic. The attributes depend on the value of the "type" attribute.
 */
export interface TransverseIsotropicElastic {
  /**
   * type = "isotropic"
   */
  type: string;
  /**
   *  The plane of isotropy, must be one of 12, 13, or 23
   */
  iso_plane: number;
  /**
   * Elastic modulus perpendicular to plane of isotropy
   */
  Ea: number;
  /**
   * Elastic modulus in plane of isotropy
   */
  Et: number;
  /**
   * Poisson ratio between axis perpendicular to plane of isotropy and an axis in the plane of isotropy. For example, if iso_plane=23, nuat would represent nu12 and nu13.
   */
  nuat: number;
  /**
   * Poisson ratio in plane of isotropy. For example, if iso_plane=23, nutt would represent nu23.
   */
  nutt: number;
}

/**
 *  Linear elastic material properties. All moduli should be given in units of MPa.
 *  This object is polymorphic. The attributes depend on the value of the "type" attribute.
 */
export interface OrthotropicElastic {
  /**
   * type = "orthotropic"
   */
  type: string;
  /**
   * Elastic modulus parallel to material 1 axis
   */
  E11: number;
  /**
   * Elastic modulus parallel to material 2 axis
   */
  E22: number;
  /**
   * Elastic modulus parallel to material 3 axis
   */
  E33: number;
  /**
   * Poisson ratio between material 1 and 2 axes
   */
  nu12: number;
  /**
   * Poisson ratio between material 1 and 3 axes
   */
  nu13: number;
  /**
   * Poisson ratio between material 2 and 3 axes
   */
  nu23: number;
  /**
   * hear modulus in 12 plane
   */
  G12: number;
  /**
   * hear modulus in 13 plane
   */
  G13: number;
  /**
   * hear modulus in 23 plane
   */
  G23: number;
}

/**
 * Yield strength properties.
 *  This object is polymorphic. The attributes depend on the value of the "type" attribute.
 */
export interface IsotropicYield {
  /**
   *s type = "isotropic"
   */
  type: string;
  /**
   * Tensile strength.
   */
  T: number;
  /**
   * Compressive strength.
   */
  C: number;
  /**
   * Shear strength.
   */
  S: number;
}

/**
 * A complete SmartSlice job definition (validation or optimization).
 */
export interface Job {
  /**
   *  The job type. Acceptable values are "validation" and "optimization".
   */
  type: string;
  /**
   * todo add definition
   */
  chop: Model;
  /**
   * List of bulk materials used in print. Currently multiple materials is not supported.
   */
  bulk: Array<Material>;
  /**
   * todo add definition
   */
  extruders: Array<Extruder>;
  /**
   * Optimization configuration if the job type is "optimization". If "validation" this can be omitted.
   */
  optimization: Optimization;
}

/**
 * Defines a load upon a given portion of the model geometry.
 * The type attribute represents the type of load. The only, current, boundary condition type is "force".
 */
export interface Load {
  /**
   * type = "force"
   */
  type: string;
  /**
   * A unique name for the load.
   */
  name: string;
  /**
   * The name of the chop.mesh.Mesh this load is applied to
   */
  mesh: string;
  /**
   * A list of face ids on "mesh" that this load is applied to.
   */
  face: Array<number>;
  /**
   * The applied force vector in Newtons.
   */
  force: Array<number>;
}


/**
 * An engineering material definition.
 */
export interface Material {
  /**
   * A unique name for the material
   */
  name: string;
  /**
   * The material density in tonnes/mm^3
   */
  density: number;
  /**
   * The material's linear elastic properties
   */
  elastic: IsotropicElastic | TransverseIsotropicElastic | OrthotropicElastic;
  /**
   * The material's yield strength properties
   */
  failure_yield: VonMisesYield | IsotropicYield;
  /**
   * The material's fracture properties
   */
  fracture: Fracture;
}

/**
 * A surface mesh geometry defined using vertices and triangles.
 */
export interface Mesh {
  /**
   * The type of mesh. Must be "normal" (a regular mesh that is part of printed geometry) or "infill" (a mesh that
   * overrides settings of normal meshes where they overlap, also referred to as a modifier mesh).
   */
  type: string;
  /**
   * A unique name for the mesh. This is used to refer to the mesh by other objects, such as boundary conditions and loads.
   */
  name: string;
  /**
   * A list of 3 float arrays that define the coordinates of the vertices.
   */
  vertices: Array<Array<number>>;
  /**
   * A list of 3 integer arrays that define the triangle connectivities. The integers refer to the indices of
   * the vertices (counting starts at zero). The computed triangle normal should point outward from the geometry
   * (consistent with the well known STL format)
   */
  triangles: Array<Array<number>>;
  /**
   * An array of 16 floats that represent the transformation matrix in flattened form in row major order.
   * The default is the identity matrix.
   */
  transform: Array<number>;
  /**
   * Print settings unique to this mesh.
   */
  print_config: PrintConfig;
}

/**
 * SmartSlice optimization parameters.
 * Current column number [if this function was defined in a script]
 */
export interface Optimization {
  /**
   * The global minimum safety factor to target in the optimization. Print configurations that contain safety
   * factors lower than this number will be thrown out.
   */
  min_safety_factor: number;
  /**
   * The global maximum displacement magntiude (in millimeters) to target in the optimization. Print configurations
   * that contain displacements that exceed this number will be thrown out.
   */
  max_displacement: number;
}

/**
 * An FDM printer definition.
 */
export interface Printer {
  /**
   * A name for the printer. This currently is not used or referenced in any logic.
   */
  name: string;
  /**
   * list of the extruders on the printer
   */
  extruders: Extruders;
}

/**
 * An FDM printer configuration definition. This can be used to apply settings globally,
 * for a specific extruder, or for a specific mesh.
 */
export interface PrintConfig {
  /**
   * The width of a printed road/extrusion in millimeters. This should be greater than or equal to the extruder's diameter.
   */
  layer_width: number;
  /**
   * The height of a printer road/extrusion/layer in millimeters. This should be less than or equal to the extruder's diameter.
   */
  layer_height: number;
  /**
   * The number of walls printed around the perimeter of a layer.
   */
  walls: number;
  /**
   * The number of bottom layers to print.
   */
  bottom_layers: number;
  /**
   * The number of top layers to print.
   * Current column number [if this function was defined in a script]
   */
  top_layers: number;
  /**
   * A list of the orientations (in degrees) that skins/layers are printed at. It is assumed the slicer
   * will start at the beginning of the list at layer 1 and iterate through the list, changing the orientation
   * of any skin/layer regions in the layer. When the end of the list is reached it starts back at the beginning.
   * For example a value of [45, 135] would alternate between 45 and 135 degree skins. 0 degree angles are parallel
   * to the print x-axis. All orientations should be 0 <= angle < 360.
   */
  skin_orientations: Array<number>;
  /**
   * Infill properties.
   */
  infill: Infill;
  /**
   * All auxiliary properties that will be passed on to the slicer. These properties may or may not affect the
   * mechanical performance of the final printed part, but generally, they are not of interest in the context of
   * SmartSlice, so they do not have specifically defined attributes in the am.Config object. SmartSlice will
   * populate this dictionary with the slicer's default properties and then override any that are defined explicitly here.
   */
  auxiliary: Record<string, unknown>;
}

/**
 * A unique set of boundary conditions and loads that are applied to the model in unison.
 */
export interface Step {
  /**
   * A unique name for the step.
   */
  name: string;
  /**
   * A list of boundary conditions applied in this step.
   */
  boundary_conditions: Array<BoundaryCondition> | Array<null>;
  /**
   * A list of loads applied in this step.
   */
  loads: Array<Load> | Array<null>;
}

/**
 * A slicing engine and print settings.
 * The type attribute represents the slicing engine to use. Currently, the only, engine supported is "cura".
 */
export interface Slicer {
  /**
   * type = "cura"
   */
  type: string;
  /**
   * The printer definition.
   */
  printer: Printer;
  /**
   * Global printer settings to be used by the slicer
   */
  print_config: PrintConfig;
}

/**
 * Yield strength properties.
 *  This object is polymorphic. The attributes depend on the value of the "type" attribute.
 */
export interface VonMisesYield {
  /**
   * type = "von_mises"
   */
  type: string;
  /**
   * von Mises strength.
   */
  Sy: number;
}

export class Model {
  meshes: Mesh[] | Array<null>;
  slicer: Slicer;
  steps: Step;

  constructor(config: Model | null = null) {
    if (config) {
      this.meshes = config.meshes;
      this.slicer = config.slicer;
      this.steps = config.steps;
    } else {
      // Set defaults
      this.meshes = [];
      this.slicer = {
        type: 'string',
        printer: {
          name: 'test',
          extruders: {
            id: 1,
            diameter: 1,
            print_config: {
              layer_height: 1,
              layer_width: 1,
              bottom_layers: 1,
              top_layers: 1,
              auxiliary: {},
              infill: {
                pattern: 'test',
                density: 1,
                orientation: 1,
              },
              walls: 1,
              skin_orientations: [1],
            },
          },
        },
        print_config: {
          skin_orientations: [1],
          infill: {
            density: 1,
            orientation: 1,
            pattern: 'test',
          },
          walls: 1,
          bottom_layers: 1,
          top_layers: 1,
          auxiliary: {},
          layer_width: 1,
          layer_height: 1,
        },
      };
      this.steps = {
        name: 'test',
        boundary_conditions: [
          {
            type: 'test',
            name: 'test',
            mesh: 'test',
            face: [1],
          },
        ],
        loads: [],
      };
    }
  }
}

export class Material {
  density: number;
  elastic: IsotropicElastic | TransverseIsotropicElastic | OrthotropicElastic;
  failure_yield: VonMisesYield | IsotropicYield;
  fracture: Fracture;
  name: string;

  constructor(config: Material = null) {
    if (config) {
      this.density = config.density;
      this.elastic = config.elastic;
      this.failure_yield = config.failure_yield;
      this.fracture = config.fracture;
      this.name = config.name;
    } else {
      // Set Defaults
      this.density = 1;
      this.elastic = {
        type: 'isotropic',
        E: 1,
        nu: 1,
      };
      this.failure_yield = {
        type: 'von_mises',
        Sy: 1,
      };
      this.fracture = {
        KIc: 1,
      };
      this.name = 'default';
    }
  }
}

export class Extruder {
  number: number;
  usable_material: Array<string>;

  constructor(config: Extruder | null = null) {
    if (config) {
      this.number = config.number;
      this.usable_material = config.usable_material;
    } else {
      this.number = 1;
      this.usable_material = ['test'];
    }
  }
}

export class Optimization {
  max_displacement: number;
  min_safety_factor: number;

  constructor(config: Optimization | null = null) {
    if (config) {
      this.max_displacement = config.max_displacement;
      this.min_safety_factor = config.min_safety_factor;
    } else {
      //    set defaults
      this.max_displacement = 1;
      this.min_safety_factor = 2;
    }
  }
}

export class Job{
  public type: string;
  chop: Model;
  bulk: Material[];
  extruders: Extruder[];
  optimization: Optimization;

  constructor(config: Job = null) {
    if (config) {
      this.type = config.type;
      this.chop = config.chop;
      this.bulk = config.bulk;
      this.extruders = config.extruders;
      this.optimization = config.optimization;
    } else {
      //    set default values
      this.type = 'validation';
      this.chop = new Model();
      this.bulk = [new Material()];
      this.extruders = [new Extruder()];
      this.optimization = new Optimization();
    }
  } 
}

class SmartSliceJob extends Job {
  job: Job
  serializedJob: string

  constructor(config: Job = null) {
    super(config)

    this.updateJob()
  }

  updateJob():void {
    this.job = {
      type: this.type,
      chop: this.chop,
      extruders: this.extruders,
      optimization: this.optimization,
      bulk: this.bulk
    }

    this.serializedJob = JSON.stringify(this.job)
  }

  getJob(serialized: boolean = false): string | Job {
    return serialized? this.serializedJob: this.job
  }
}